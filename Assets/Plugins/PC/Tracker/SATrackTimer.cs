//// Created by 储强盛 on 2023/3/17.// Copyright © 2015-2023 Sensors Data Co., Ltd. All rights reserved.//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at////      http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.//using System.Collections.Generic;using System.Linq;using SensorsAnalyticsPCSDK.Constant;

namespace SensorsAnalyticsPCSDK.Tracker{
    public class SATrackTimer    {        // 支持客户使用原始事件名，直接暂停恢复或结束事件计时        private Dictionary<string, Dictionary<string, object>> _eventNames = new Dictionary<string, Dictionary<string, object>>();        // 支持交叉计时，即同一事件名，不同场景，分别计时，比如针对不同视频播放、暂停或恢复等        private Dictionary<string, Dictionary<string, object>> _eventIds = new Dictionary<string, Dictionary<string, object>>();        /// <summary>        /// 生成事件计时的 eventId        /// </summary>        /// <param name="eventName">事件名或 eventId</param>        /// <returns></returns>        public string GenerateEventIdByEventName(string eventName)        {            string eventId = eventName;            if (string.IsNullOrEmpty(eventId))            {                return eventId;            }            if (!eventName.EndsWith(SAConstant.kSAEventIdSuffix))            {                string uuid = System.Guid.NewGuid().ToString().Replace("-", "_");                eventId = string.Format("{0}_{1}{2}", eventName, uuid, SAConstant.kSAEventIdSuffix);            }            return eventId;        }        // 开始事件计时        public void TrackTimerStart(string eventId, int currentSysUpTime)        {            Dictionary<string, object> parameters = new Dictionary<string, object>();            parameters.Add("eventBegin", currentSysUpTime);            parameters.Add("eventAccumulatedDuration", 0.0f);            parameters.Add("isPause", false);            _eventIds[eventId] = parameters;            string eventName = EventNameFromEventId(eventId);            _eventNames[eventName] = parameters;        }        // 暂停事件计时        public void TrackTimerPause(string eventId, int currentSysUpTime)        {            //此处根据优先级先查找 eventIds 表再查找 eventNames 表，如果 eventIds 表匹配成功停止后续查询            if (HandleEventPause(eventId, _eventIds, currentSysUpTime))            {                return;            }            HandleEventPause(eventId, _eventNames, currentSysUpTime);        }        // 恢复事件计时        public void TrackTimerResume(string eventId, int currentSysUpTime)        {            //此处根据优先级先查找 eventIds 表再查找 eventNames 表，如果 eventIds 表匹配成功停止后续查询            if (HandleEventResume(eventId, _eventIds, currentSysUpTime))            {                return;            }            HandleEventResume(eventId, _eventNames, currentSysUpTime);        }        // 删除事件计时        public void TrackTimerRemove(string eventId)        {            if (_eventIds.ContainsKey(eventId))            {                _eventIds.Remove(eventId);                return;            }            if (_eventNames.ContainsKey(eventId))            {                _eventNames.Remove(eventId);            }        }        // 计算事件时长        public float EventDurationFromEventId(string eventId, int currentSysUpTime)        {            if(string.IsNullOrEmpty(eventId))            {                return 0;            }            //为了保证获取事件时长的准确性，计算时长时需要从外部传入当前系统开机时间            //事件计时 eventIds 表优先级更高，在 eventIds 表中查询不到时再查询 eventNames 表            float duration = HandleEventDuration(eventId, _eventIds, currentSysUpTime);            if (duration == 0)            {                duration = HandleEventDuration(eventId, _eventNames, currentSysUpTime);            }            return duration;        }        // 移除所有事件计时        public void ClearAllEventTimers()        {            _eventNames.Clear();            _eventIds.Clear();        }        // 暂停所有事件计时        public void PauseAllEventTimers(int currentSystemUpTime)        {            HandleAllEventsPause(_eventIds, currentSystemUpTime);            HandleAllEventsPause(_eventNames, currentSystemUpTime);        }        // 恢复所有事件计时        public void ResumeAllEventTimers(int currentSystemUpTime)        {            HandleAllEventsResume(_eventIds, currentSystemUpTime);            HandleAllEventsResume(_eventNames, currentSystemUpTime);        }        // 获取计时事件原始事件名        private string EventNameFromEventId(string eventId)        {            if (!eventId.EndsWith(SAConstant.kSAEventIdSuffix))            {                return eventId;            }            //eventId 结构为 {eventName}_D3AC265B_3CC2_4C45_B8F0_3E05A83A9DAE_SATimer，新增后缀长度为 44            string eventName = eventId.Substring(0, eventId.Length - 1 - 44);            return eventName;        }        private float HandleEventDuration(string eventId, Dictionary<string, Dictionary<string, object>> mapping, int currentSystemUpTime)        {            Dictionary<string, object> eventTimer;            if (!mapping.TryGetValue(eventId, out eventTimer))            {                return 0;            }            mapping.Remove(eventId);            int eventBegin = (int)eventTimer["eventBegin"];            float eventAccumulatedDuration = (float)eventTimer["eventAccumulatedDuration"];            bool isPause = (bool)eventTimer["isPause"];            float eventDuration = 0;            if (!isPause)            {                eventDuration = EventTimerDurationWithCurrentTime(currentSystemUpTime, eventBegin);            }            eventDuration += eventAccumulatedDuration;            return eventDuration;        }        private bool HandleEventPause(string eventId, Dictionary<string, Dictionary<string, object>> mapping, int currentSystemUpTime)        {            Dictionary<string, object> eventTimer;            if (!mapping.TryGetValue(eventId, out eventTimer))            {                return false;            }            bool isPause = (bool)eventTimer["isPause"];            if (!isPause)            {                int eventBegin = (int)eventTimer["eventBegin"];                isPause = true;                float eventDuration = EventTimerDurationWithCurrentTime(currentSystemUpTime, eventBegin);                eventTimer["eventBegin"] = eventBegin;                eventTimer["isPause"] = isPause;                if (eventDuration > 0)                {                    eventTimer["eventAccumulatedDuration"] = ((float)eventTimer["eventAccumulatedDuration"]) + eventDuration;                }                mapping[eventId] = eventTimer;                return true;            }            return false;        }        private bool HandleEventResume(string eventId, Dictionary<string, Dictionary<string, object>> mapping, int currentSystemUpTime)        {            Dictionary<string, object> eventTimer;            if (!mapping.TryGetValue(eventId, out eventTimer))            {                return false;            }            bool isPause = (bool)eventTimer["isPause"];            if (isPause)            {                isPause = false;                eventTimer["eventBegin"] = currentSystemUpTime;                eventTimer["isPause"] = isPause;                mapping[eventId] = eventTimer;                return true;            }            return false;        }        // 暂停所有事件计时        private void HandleAllEventsPause(Dictionary<string, Dictionary<string, object>> mapping, int currentSystemUpTime)        {            if (mapping == null || mapping.Count == 0)            {                return;            }            // 使用 foreach 遍历同时修改 value，会抛异常            var allKeys = mapping.Keys.ToArray();            for (int index = 0; index < allKeys.Length; index ++)            {                string key = allKeys[index];                if (!string.IsNullOrEmpty(key))                {                    if (key == SAConstant.kSAEventNameAppEnd)                    {                        continue;                    }                }                //当前逻辑只会在 App 进入到后台时调用                //此处逻辑和暂停单个事件计时不同，暂停所有事件时不更改 isPause 状态，只累加已累计时长                Dictionary<string, object> eventTimer = mapping[key] as Dictionary<string, object>;                if (eventTimer != null && !(bool)eventTimer["isPause"])                {                    int eventBegin = (int)eventTimer["eventBegin"];                    float eventAccumulatedDuration = (float)eventTimer["eventAccumulatedDuration"];                    float eventDuration = EventTimerDurationWithCurrentTime(currentSystemUpTime, eventBegin);                    eventDuration += eventAccumulatedDuration;                    eventTimer["eventAccumulatedDuration"] = eventDuration;                    eventTimer["eventBegin"] = currentSystemUpTime;                    mapping[key] = eventTimer;                }            }        }        // 恢复所有事件计时        private void HandleAllEventsResume(Dictionary<string, Dictionary<string, object>> mapping, int currentSystemUpTime)        {            if(mapping == null || mapping.Count == 0)            {                return;            }            //当前逻辑只会在 App 进入到前台时调用            // 遍历 trackTimer ,修改 eventBegin 为当前 currentSystemUpTime            //此处逻辑和恢复单个事件计时不同，恢复所有事件时不更改 isPause 状态，只修改事件开始时间 eventBegin            var allKeys = mapping.Keys.ToArray();            for (int index = 0; index < allKeys.Length; index++)            {                string key = allKeys[index];                Dictionary<string, object> eventTimer = mapping[key] as Dictionary<string, object>;                if (eventTimer != null)                {                    eventTimer["eventBegin"] = currentSystemUpTime;                    mapping[key] = eventTimer;                }            }        }        //计算事件时长        private float EventTimerDurationWithCurrentTime(int currentSystemUpTime, int startTime)        {            if (startTime <= 0)            {                return 0;            }            float eventDuration = (float)(currentSystemUpTime - startTime);            eventDuration = eventDuration / 1000.0f;            return eventDuration;        }    }
}
